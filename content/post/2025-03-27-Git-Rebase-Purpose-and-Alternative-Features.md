---
publish: true
 draft: false
title: Git Rebase 사용 목적 및 대체 기능
description: Rebase를 대체할 기능이 있음에도 사용하는 이유가 궁금하다.
author: Nine
date: 2025-03-27
categories:
  - VersionControl
  - Git
tags:
  - devlog
  - 형상관리
  - VersionControl
  - Git

Status: Done
---
## 📌개요

`merge` 기능이 있지만 `rebase`를 사용하는 목적?
사용에 주의가 필요한 기능이라면, 협업에선 어떤 상황에 사용되는지?

## 📌내용

### Rebase 사용 목적

>[!warning] `rebase`는 개인적으로 작업하는 브랜치나 깔끔한 히스토리를 유지해야 하는 경우에 유용하게 사용된다. 하지만 공유 브랜치에서는 협업 시 혼란을 야기할 수 있으므로 사용에 신중해야 한다.

`rebase`는 브랜치 변경 사항을 다른 브랜치에 통합하는 강력한 도구로, 특히 다음과 같은 목적을 위해 사용된다.

- `merge`와 달리 불필요한 병합 커밋을 생성하지 않고 히스토리를 재작성하여 이해하기 쉽고 추적하기 용이한 선형적인 히스토리를 유지한다.
- 선형적인 히스토리는 코드 변경 사항을 순차적으로 검토할 수 있도록 도와 코드 리뷰 효율성을 높인다.
- `git bisect`와 같은 도구를 사용하여 문제 발생 커밋을 빠르게 찾고 해결하는 데 유용하다.
- `interactive rebase`를 통해 커밋 순서 변경, 병합, 삭제 등 다양한 방법으로 커밋 히스토리를 정리하고 관리할 수 있다.

### Rebase 대체 기능 및 비교

`rebase`와 유사한 기능을 수행하는 `merge`가 있으며, 두 기능의 차이점은 다음과 같다.

| 기능     | 특징                | 장점                                                        | 단점                                                       |
| ------ | ----------------- | --------------------------------------------------------- | -------------------------------------------------------- |
| merge  | 브랜치 병합 시 병합 커밋 생성 | 히스토리 변경 없이 브랜치 병합 가능<br>안정적인 협업환경 유지                      | 복잡한 커밋 히스토리 생성<br>코드 리뷰 및 문제 해결 어려움                      |
| rebase | 커밋 히스토리 재작성       | 깔끔하고 선형적인 커밋 히스토리 유지<br>코드 리뷰 및 문제 해결 용이<br>커밋 정리 및 관리 용이 | 커밋 히스토리 변경으로 인한 잠재적 문제 발생 가능성<br>숙련되지 않은 사용자에게는 복잡할 수 있음 |
- `merge`는 히스토리 변경 없이 브랜치를 병합하고 안정적인 협업 환경을 유지하는데 적합하다.
- `rebase`는 깔끔하고 선형적인 히스토리를 유지하고 코드 리뷰 및 문제 해결 효율성을 높이는 데 적합하다.

### Rebase 사용 사례

>[!info] 기능 브랜치 정리, 코드 리뷰 효율성 향상, release 브랜치 관리, 옾느 소스 프로젝트 기여 등에 사용할 수 있다.

#### main 브랜치 병합 전 Rebase를 통한 커밋 정리

여러 개발자가 `feature-A`라는 브랜치에서 동시에 작업한다고 생각해보자.
각 개발자는 자신의 작업을 커밋하고 원격 저장소에 푸시할 것이다.
`feature-A` 브랜치를 `main` 브랜치에 병합하기 전에, 각 개발자는 자신의 커밋을 정리하고 `main` 브랜치의 최신 변경 사항을 반영하기 위해 `rebase`를 사용한다.

#### 개발자 A의 작업

- 개발자 A는 `feature-A` 브랜치에서 작업을 수행하고 다음과 같은 커밋을 생성한다.
	- 커맷 1: 기능 A의 기본 구조 구현
	- 커밋 2: 기능 A의 UI 개선
	- 커밋 3: 기능 A의 버그 수정
- 개발자 A는 자신의 커밋을 원격 저장소에 푸시한다.

#### 개발자 B의 작업

- 개발자 B도 `feature-A` 브랜치에서 작업을 수행하고 다음과 같은 커밋을 생성한다.
	- 커밋 1: 기능 A의 데이터 처리 로직 구현
	- 커밋 2: 기능 A의 성능 개선
- 개발자 B는 자신의 커밋을 원격 저장소에 푸시한다.


#### 작업 후 merge 이전의 rebase

>[!warning] 브랜치의 작업자가 본인만 있는 경우가 아니라면, 강제 푸시 이전 꼭 협업자와의 소통이 필수.

>개발자 B 역시 동일하게 본인의 커밋을 수정할 수 있다.

두서 없이 작업했던 본인의 커밋 내역을 `main` 브랜치에 합치기 위해 작업 내역을 정리하는 목적으로 사용할 수 있다.

##### 최신 변경 사항 가져오기

`main` 브랜치의 최신 변경 사항을 로컬 `feature-A` 브랜치에 가져온다.

```bash
git pull origin main
```

##### rebase 시작

`rebase`를 시작한다.
로컬 `feature-A` 브랜치의 커밋들을 `main` 브랜치의 최신 커밋 위에 재배치한다.

```bash
git rebase origin/main
```

##### 충돌 발생 시 해결

- 충돌이 발생하면 충돌 파일을 수정하고 `git add {충돌난 파일}` 명령어를 실행한다.
- `git rebase --continue` 명령으로 `rebase`를 계속 진행한다.

##### interactive rebase (선택 사항)

커밋 히스토리를 정리한다.
- `commit`을 수정하거나
- 커밋을 합치거나
- 불필요한 커밋을 삭제하는 등 

```bash
git rebase -i origin/main
```

##### 원격 저장소에 강제 푸시

정리된 커밋 히스토리를 원격 저장소에 강제 푸시한다.
이로 인해 협업 규격에 맞는 커밋으로 수정한 뒤 `main` 브랜치에 합칠 수 있게 된다.

```bash
git push --force-with-lease origin feature-A
```

## 🎯결론

`rebase`는 개인 작업의 유연성과 협업 시 커밋 규격 준수를 가능하게 하는 강력한 도구이지만, 히스토리 변경으로 인한 위험성을 항상 염두에 두어야 한다.
따라서, `rebase`를 사용할 때는 팀원들과 충분히 소통하고 프로젝트의 특성을 고려해서 신중하게 결정해야 한다.

## ⚙️EndNote

### origin main VS origin/main

#### origin main

`origin main`는 나눠서 봐야 한다.
`origin`이라는 원본 저장소, `main`이라는 브랜치

예를 들어, `git pull origin main` 명령이라면 `origin`이라는 저장소에서 `main` 브랜치를 내려 받는다.

#### origin/main

`origin/main`은 브랜치 자체를 의미한다.
로컬 저장소에 저장된 원격 저장소 `origin`의 `main` 브랜치의 상태를 나타내는 일종의 '읽기 전용' 스냅샷이다.

예를 들어, `git rebase origin/main` 명령이라면 `origin/main` 브랜치에 대해 `rebase`를 실행한다.