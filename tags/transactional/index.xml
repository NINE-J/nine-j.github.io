<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Transactional on B9F1</title><link>https://b9f1.com/tags/transactional/</link><description>Recent content in Transactional on B9F1</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 10 Oct 2025 19:41:23 +0900</lastBuildDate><atom:link href="https://b9f1.com/tags/transactional/index.xml" rel="self" type="application/rss+xml"/><item><title>MSA Outbox 패턴</title><link>https://b9f1.com/p/2025-10-10-outbox-patterns-for-data-consistency-and-event-reliability-in-msa/</link><pubDate>Fri, 10 Oct 2025 19:41:23 +0900</pubDate><guid>https://b9f1.com/p/2025-10-10-outbox-patterns-for-data-consistency-and-event-reliability-in-msa/</guid><description>&lt;img src="https://b9f1.com/p/2025-10-10-outbox-patterns-for-data-consistency-and-event-reliability-in-msa/cover.png" alt="Featured image of post MSA Outbox 패턴" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;MSA에서 각 서비스는 독립적인 데이터베이스와 메시지 브로커를 사용하며 이를 통해 비동기 이벤트를 교환한다.&lt;/p&gt;
&lt;p&gt;하지만 이 구조는 하나의 트랜잭션 내에서 데이터 저장과 이벤트 발행이 분리되기 때문에 데이터 일관성과 메시지 신뢰성을 보장하기 어렵다.&lt;/p&gt;
&lt;p&gt;예를 들어 결제 서비스가 결제 정보를 DB에 저장한 후 kafka에 결제 완료 이벤트를 발행한다고 하자. 만약 DB 저장은 성공했지만 kafka 발행이 실패한다면?
결제는 되었는데 알림 서비스나 배송 서비스는 이를 모르게 된다.&lt;/p&gt;
&lt;p&gt;이런 문제를 해결하기 위한 안전한 전략이 바로 Outbox 패턴이다.&lt;/p&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;Info&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;Outbox는 보낼 편지함이라는 뜻이며 &lt;code&gt;Transactional Outbox Pattern&lt;/code&gt;으로 조회했을 때 다양한 정보가 있었다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="문제-상황"&gt;문제 상황
&lt;/h3&gt;&lt;p&gt;MSA 환경에서 다음과 같은 불일치가 자주 발생한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DB에는 반영되었지만 이벤트 발행 실패&lt;/li&gt;
&lt;li&gt;이벤트는 발행되었지만 데이터 저장 실패&lt;/li&gt;
&lt;li&gt;중복 발행 및 순서 불일치&lt;/li&gt;
&lt;li&gt;서비스 간 재시도 로직으로 인한 중복 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이는 &lt;strong&gt;DB 트랜잭션과 메시지 발행이 원자적(atomic)&lt;/strong&gt; 으로 묶여있지 않기 때문에 발생한다.&lt;/p&gt;
&lt;h3 id="기존-접근의-한계"&gt;기존 접근의 한계
&lt;/h3&gt;&lt;h4 id="2pctwo-phase-commit"&gt;2PC(Two-Phase Commit)
&lt;/h4&gt;&lt;p&gt;DB와 메시지 브로커가 XA 트랜잭션을 지원해야 하며, 락 경합과 네트워크 오버헤드로 인해 확장성 측면에서 부적합하다.&lt;/p&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;XS 트랜잭션&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;표준화된 분산 트랜잭션 구현 XA(eXtended Architecture)는 2PC(2 phase commit)을 통한 분산 트랜잭션 처리를 위해 X-Open에서 명시한 표준이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="application-level-retry"&gt;Application-Level Retry
&lt;/h4&gt;&lt;p&gt;애플리케이션에서 발행 실패 시 재시도를 구현할 수 있지만 네트워크 장애나 장애 복구 시점에 따라 &lt;strong&gt;중복 이벤트&lt;/strong&gt; 또는 &lt;strong&gt;순서 역전&lt;/strong&gt;이 발생할 수 있다.&lt;/p&gt;
&lt;h3 id="outbox-패턴으로-해결할-수-있는-것"&gt;Outbox 패턴으로 해결할 수 있는 것
&lt;/h3&gt;&lt;p&gt;Outbox 패턴은 &lt;strong&gt;비즈니스 데이터와 이벤트를 동일 트랜잭션 내에서 처리하고&lt;/strong&gt; 이후 별도의 &lt;strong&gt;Message Relay 프로세스&lt;/strong&gt;가 메시지 브로커(Kafka, RabbitMQ 등)에 발행하는 구조다.&lt;/p&gt;
&lt;p&gt;이 방식은 트랜잭션 일관성과 메시지 신뢰성을 모두 확보한다.&lt;/p&gt;
&lt;h4 id="처리-흐름-요약"&gt;처리 흐름 요약
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;비즈니스 트랜잭션 수행&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ORDER&lt;/code&gt; 테이블에 INSERT / UPDATE / DELETE 수행&lt;/li&gt;
&lt;li&gt;같은 트랜잭션 내에서 &lt;code&gt;OUTBOX&lt;/code&gt; 테이블에 이벤트 메시지(페이로드) 저장&lt;/li&gt;
&lt;li&gt;두 테이블은 &lt;strong&gt;하나의 트랜잭션 단위&lt;/strong&gt;로 커밋됨, 원자성(Atomicity) 확보&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 릴레이(Message Relay)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션이 커밋된 후, 별도 프로세스가 &lt;code&gt;OUTBOX&lt;/code&gt; 테이블을 주기적으로 읽음&lt;/li&gt;
&lt;li&gt;발행되지 않은 이벤트(&lt;code&gt;status = NEW&lt;/code&gt;)를 찾아 메시지 브로커에 Publish&lt;/li&gt;
&lt;li&gt;발행 성공 시 &lt;code&gt;status = PUBLISHED&lt;/code&gt;로 갱신&lt;/li&gt;
&lt;li&gt;실패 시 재시도 로직 또는 DLQ(Dead Letter Queue)로 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메시지 브로커&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Kafka, RabbitMQ, AWS SNS/SQS 등으로 메시지 전달&lt;/li&gt;
&lt;li&gt;구독 서비스들이 해당 이벤트를 비동기적으로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="mermaid-container zoomable"&gt;
&lt;pre class="mermaid"&gt;
flowchart LR
A[Order Service] --&gt;|INSERT/UPDATE/DELETE| B[(ORDER table)]
A --&gt;|INSERT event| C[(OUTBOX table)]
subgraph Database
B
C
end
C --&gt;|Read Outbox| D[Message Relay]
D --&gt;|Publish Event| E[Message Broker]
classDef highlight fill:#f4f4f4,stroke:#666,stroke-width:1px;
class B,C highlight
&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id="구성-요소"&gt;구성 요소
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sender (Order Service):&lt;/strong&gt; 비즈니스 로직 수행 및 Outbox에 이벤트 기록&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Database:&lt;/strong&gt; 비즈니스 데이터(&lt;code&gt;ORDER&lt;/code&gt;)와 이벤트 로그(&lt;code&gt;OUTBOX&lt;/code&gt;)를 함께 저장&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message Outbox:&lt;/strong&gt; 발행 대기 중인 이벤트를 저장하는 테이블 또는 컬렉션&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message Relay:&lt;/strong&gt; Outbox 테이블에서 이벤트를 읽어 메시지 브로커로 발행&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message Broker:&lt;/strong&gt; 이벤트를 다른 서비스에 전달 (Kafka, RabbitMQ 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="주요-장점"&gt;주요 장점
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;항목&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;트랜잭션 일관성 보장&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DB 저장과 이벤트 기록이 하나의 트랜잭션으로 처리됨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;재처리 가능&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Outbox 테이블을 기준으로 실패한 이벤트를 재전송 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;멱등성(idempotency)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;이벤트 발행 시 &lt;code&gt;event_id&lt;/code&gt;로 중복 처리 방지&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Kafka Connect / Debezium 등을 통해 Change Data Capture(CDC) 기반으로 확장 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="outbox--cdcchange-data-capture"&gt;Outbox + CDC(Change Data Capture)
&lt;/h3&gt;&lt;p&gt;단순 폴링 기반은 부하가 크기 때문에 &lt;strong&gt;Debezium + Kafka Connect&lt;/strong&gt; 조합을 사용하기도 한다.
DB 트랜잭션 로그를 구독하여 outbox 테이블의 변경 사항만 캡처해 이벤트를 발행하므로 효율적이다.&lt;/p&gt;
&lt;h3 id="유사-패턴과-비교"&gt;유사 패턴과 비교
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;패턴&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;한계&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Saga 패턴&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;여러 서비스 트랜잭션을 보상 트랜잭션으로 관리&lt;/td&gt;
&lt;td&gt;복잡한 보상 로직, 순차적 지연&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Event Sourcing&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;상태를 이벤트 스트림으로 저장&lt;/td&gt;
&lt;td&gt;이벤트 재생 비용, 복잡한 쿼리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Outbox 패턴&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;이벤트를 별도 테이블에 기록 후 발행&lt;/td&gt;
&lt;td&gt;Outbox 테이블 관리 필요&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="적용-시-고려사항"&gt;적용 시 고려사항
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Outbox 테이블은 주기적으로 정리(cleanup) 필요&lt;/li&gt;
&lt;li&gt;이벤트 발행 실패 시 재시도 정책 및 DLQ(Dead Letter Queue) 구성&lt;/li&gt;
&lt;li&gt;발행 순서 보장을 위한 파티셔닝 키 설계 (&lt;code&gt;aggregate_id&lt;/code&gt; 기반)&lt;/li&gt;
&lt;li&gt;Kafka 등 메시지 브로커의 전달 보증 설정 (&lt;code&gt;at-least-once&lt;/code&gt; vs &lt;code&gt;exactly-once&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;발행 중복 대비를 위한 멱등 처리 전략 (&lt;code&gt;unique event_id&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="outbox-패턴-적용-관련-트러블슈팅"&gt;Outbox 패턴 적용 관련 트러블슈팅
&lt;/h3&gt;&lt;p&gt;날씨 정보로 사용자의 OOTD를 추천하는 서비스(피드 공유, DM 등 SNS 기능 포함)
날씨 도메인을 담당하는 팀원의 PR을 리뷰하다가 특이한 상황을 만났다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;배치 잡을 실행하며 특별한 날씨 변화가 감지되면 알림을 생성하는 케이스&lt;/li&gt;
&lt;li&gt;해당 테스트는 다른 테스트의 DB와 충돌이 없도록 독립된 인메모리 DB로 실행.&lt;/li&gt;
&lt;li&gt;로컬 테스트 코드에서 실행 시 성공 또는 무한 루프로 인한 실패. 성공 보장이 안 됨.&lt;/li&gt;
&lt;li&gt;특이하게 CI 이력엔 성공 케이스만 있음.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="로직-점검"&gt;로직 점검
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;outboxes&lt;/code&gt;가 비었을 때만 &lt;code&gt;FINISHED&lt;/code&gt;, 기본은 &lt;code&gt;CONTINUABLE&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;모든 이벤트를 발송하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;수신 대상이 없어도 &lt;code&gt;SENDING&lt;/code&gt; 상태로 저장하는 결함 발견
&lt;ul&gt;
&lt;li&gt;수신 대상이 없어서 &lt;code&gt;outbox&lt;/code&gt;가 처리되지 않고 계속 남아있으며 &lt;code&gt;CONTINUABLE&lt;/code&gt; 무한 루프&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만 간헐적인 성공과 CI에서만 성공하는 건 설명되지 않음.&lt;/p&gt;
&lt;h4 id="성공-조건과-실패-조건-점검"&gt;성공 조건과 실패 조건 점검
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;왜 로컬에선 무한 루프로 실패하는 케이스가 있고 CI에선 정상 동작하지?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;성공의 조건
&lt;ul&gt;
&lt;li&gt;배치 실행 시점에 &lt;code&gt;PENDING&lt;/code&gt; &lt;code&gt;outbox&lt;/code&gt;가 비어있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실패의 조건
&lt;ul&gt;
&lt;li&gt;배치 시작 후, &lt;code&gt;PENDING&lt;/code&gt; &lt;code&gt;outbox&lt;/code&gt; 조회 쿼리와 수신 대상 조회 쿼리가 반복&lt;/li&gt;
&lt;li&gt;수신 대상이 0명인 경우: &lt;code&gt;SENDING&lt;/code&gt;으로 바꾸지 않음, 여전히 &lt;code&gt;PENDING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Step이 종료되지 않고 같은 쿼리를 계속 내며 무한 반복&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;질문이 잘못됐다..! 로컬과 CI로 구분해서 볼 게 아니라 로직 점검에서 확인했던 &lt;code&gt;outbox&lt;/code&gt;의 생성 여부를 봤어야 했다. &amp;ldquo;outboxes가 비었을 때만 &lt;code&gt;FINISHED&lt;/code&gt;&amp;rdquo; 였으니까..&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;즉, 특별한 날씨 변화가 있는가? 였다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;날씨 조회에 대한 것도 Mocking 하거나 수신 대상을 보장하는 등 다양한 방법이 있었을텐데 정답이 없다 보니 발생했던 문제 같다.&lt;/p&gt;
&lt;p&gt;특이하게 CI에 성공 이력만 있던 것도 마침 그때는 특별한 날씨 변화가 없던 것&amp;hellip;&lt;/p&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;&lt;p&gt;Outbox 패턴은 &lt;strong&gt;MSA 환경에서 데이터 일관성과 이벤트 신뢰성을 확보하는 현실적인 대안&lt;/strong&gt;이 될 수 있다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션 ACID 속성&lt;/li&gt;
&lt;li&gt;메시지 브로커의 전달 보증 (&lt;code&gt;at-least-once&lt;/code&gt;, &lt;code&gt;exactly-once&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Saga, 2PC, Event Sourcing 패턴&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://ssonzm.tistory.com/148" target="_blank" rel="noopener"
&gt;분산 트랜잭션과 XA 트랜잭션에 대해&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://devocean.sk.com/blog/techBoardDetail.do?ID=165445&amp;amp;boardType=techBlog" target="_blank" rel="noopener"
&gt;[MSA 패턴] SAGA, Transactional Outbox 패턴 활용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://microservices.io/patterns/data/transactional-outbox.html#:~:text=The%20solution%20is%20for%20the,messages%20to%20the%20message%20broker" target="_blank" rel="noopener"
&gt;Pattern: Transactional outbox&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="추가-정리"&gt;추가 정리
&lt;/h3&gt;&lt;h4 id="단일-인스턴스monolithic-환경"&gt;단일 인스턴스(Monolithic) 환경
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;하나의 DB, 하나의 트랜잭션에서 모든 로직이 처리된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2PC(2-Phase Commit)&lt;/strong&gt; 같은 표준 트랜잭션 메커니즘으로 DB 저장과 이벤트 처리(예: 메시지 큐 발행)를 하나의 논리적 단위로 묶을 수 있다.&lt;/li&gt;
&lt;li&gt;따라서 &lt;strong&gt;원자성(Atomicity)&lt;/strong&gt; 과 &lt;strong&gt;일관성(Consistency)&lt;/strong&gt; 이 보장된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="확장-시-한계-락-경쟁--처리-병목"&gt;확장 시 한계 (락 경쟁 &amp;amp; 처리 병목)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;트래픽 증가 → DB Connection Pool 경쟁 → 락 경합(lock contention) 증가&lt;/li&gt;
&lt;li&gt;대규모 트랜잭션으로 인해 응답 지연 발생&lt;/li&gt;
&lt;li&gt;DB가 &lt;strong&gt;트랜잭션 코디네이터&lt;/strong&gt; 역할까지 하므로 병목이 심화된다.&lt;/li&gt;
&lt;li&gt;이 시점에서 &lt;strong&gt;단일 DB 트랜잭션 구조는 확장성의 한계&lt;/strong&gt;에 부딪힌다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="분산-환경-msa-도입"&gt;분산 환경(= MSA 도입)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;각 서비스가 &lt;strong&gt;독립된 DB&lt;/strong&gt;를 가지게 되고 서비스 간에는 &lt;strong&gt;비동기 메시지 큐(Kafka, RabbitMQ, SNS/SQS)&lt;/strong&gt; 로 이벤트를 전달한다.&lt;/li&gt;
&lt;li&gt;이로 인해 처리 속도는 비약적으로 향상된다. (주요 비즈니스 로직만 빠르게 커밋, 나머지는 비동기로 후처리)&lt;/li&gt;
&lt;li&gt;하지만 &lt;strong&gt;데이터 일관성 문제&lt;/strong&gt;가 새롭게 등장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="새로운-문제-원자성-붕괴"&gt;새로운 문제: 원자성 붕괴
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;비즈니스 트랜잭션(DB 커밋)과 이벤트 발행(Message Send)이 &lt;strong&gt;서로 다른 시스템&lt;/strong&gt;에서 발생&lt;/li&gt;
&lt;li&gt;두 작업 중 하나라도 실패하면 데이터 불일치 발생&lt;/li&gt;
&lt;li&gt;메시지 순서가 바뀌거나 중복 이벤트가 발생할 수도 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="outbox-패턴의-해결-방식"&gt;Outbox 패턴의 해결 방식
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;서비스 로직 트랜잭션 안에서 &lt;strong&gt;비즈니스 데이터 + 이벤트 로그(Outbox)를 함께 커밋&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이로써 “이벤트 기록”까지는 &lt;strong&gt;원자성 보장&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이후 별도 프로세스(Message Relay)가 Outbox 테이블을 읽어 메시지 브로커(Kafka 등)에 발행&lt;/li&gt;
&lt;li&gt;발행이 성공하면 상태를 &lt;code&gt;PUBLISHED&lt;/code&gt;로 변경 실패하면 재시도 또는 DLQ(Dead Letter Queue)로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="mermaid-container zoomable"&gt;
&lt;pre class="mermaid"&gt;
sequenceDiagram
autonumber
participant Service as Order Service
participant DB as Database
participant Relay as Message Relay
participant Kafka as Kafka Broker
rect rgb(240, 248, 255)
Note over Service,DB: [서비스 트랜잭션 - 동기 처리]
Service-&gt;&gt;DB: INSERT INTO orders (...)
Service-&gt;&gt;DB: INSERT INTO outbox_event (...)
DB--&gt;&gt;Service: COMMIT (단일 트랜잭션으로 원자성 확보)
end
rect rgb(250, 250, 250)
Note over Relay,Kafka: [비동기 메시지 릴레이 - Outbox Poller]
Relay-&gt;&gt;DB: SELECT * FROM outbox_event WHERE status = 'NEW'
Relay-&gt;&gt;Kafka: Publish Event to Kafka
Kafka--&gt;&gt;Relay: ACK
Relay-&gt;&gt;DB: UPDATE outbox_event SET status = 'PUBLISHED'
end
&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id="결과적으로"&gt;결과적으로
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구분&lt;/th&gt;
&lt;th&gt;기존 구조&lt;/th&gt;
&lt;th&gt;Outbox 적용 후&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;원자성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DB ↔ MQ 분리되어 깨짐&lt;/td&gt;
&lt;td&gt;동일 트랜잭션 내 Outbox 기록으로 보장&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;단일 DB 락 병목&lt;/td&gt;
&lt;td&gt;분산 환경 + 비동기 처리로 개선&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;발행 실패 시 유실 가능&lt;/td&gt;
&lt;td&gt;Outbox 재시도 / CDC로 회복 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;운영 복잡도&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;단순&lt;/td&gt;
&lt;td&gt;Outbox 테이블 관리 필요(운영비 증가)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description></item><item><title>Spring에서 AOP란</title><link>https://b9f1.com/p/2025-04-17-spring-aop-and-oop/</link><pubDate>Sun, 18 May 2025 15:20:00 +0900</pubDate><guid>https://b9f1.com/p/2025-04-17-spring-aop-and-oop/</guid><description>&lt;img src="https://b9f1.com/p/2025-04-17-spring-aop-and-oop/cover.png" alt="Featured image of post Spring에서 AOP란" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;Spring에서 OOP(Object Oriented Programming) 만큼이나 강조되는 AOP(Aspect Oriented Programming)은 언제, 왜 필요할까?&lt;/p&gt;
&lt;p&gt;또한 AOP와 OOP는 대립되는 개념이 아니라는 것.
서로를 보완하며 강력한 설계를 가능케 하는지 알아보자.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="왜-aop가-필요한가"&gt;왜 AOP가 필요한가?
&lt;/h3&gt;&lt;p&gt;Spring Framework의 핵심 철학은 POJO와 OOP 기반의 설계다.
하지만 서비스가 복잡해질수록 로깅, 트랜잭션, 보안 등 공통 관심사가 여기저기 흩어져 코드를 어지럽힌다.&lt;/p&gt;
&lt;p&gt;예를 들어 다음과 같은 로직을 생각해보자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@Transactional&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;createUser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UserRequest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;사용자 생성 시작&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;validate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;userRepository&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toEntity&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;사용자 생성 완료&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;이 메서드는 핵심 기능 외에도 트랜잭션 처리, 로깅이라는 &lt;strong&gt;횡단 관심사(cross-cutting concerns)&lt;/strong&gt; 를 포함하고 있다.&lt;/p&gt;
&lt;p&gt;이러한 코드가 여러 메서드에 중복되면 유지보수와 확장성이 심각하게 저하된다.
AOP는 이런 문제를 해결하기 위해 등장했다.&lt;/p&gt;
&lt;h4 id="로그인-감사-로깅"&gt;로그인 감사 로깅
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@Aspect&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Component&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LoginLoggingAspect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nd"&gt;@Around&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;@annotation(com.example.annotation.Auditable)&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;logLogin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ProceedingJoinPoint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;joinPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;throws&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Throwable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;joinPoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;proceed&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;[AUDIT] {} executed in {}ms&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;joinPoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSignature&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;사용자 정의 어노테이션 &lt;code&gt;@Auditable&lt;/code&gt;을 붙인 메서드에 감사 로깅이 적용된다.
핵심 로직과 분리되어 있기 때문에 유지보수가 쉬워지고 로직이 더 깔끔해진다.&lt;/p&gt;
&lt;h3 id="aop-vs-oop"&gt;AOP VS OOP
&lt;/h3&gt;&lt;p&gt;AOP와 OOP는 결코 대립하지 않는다.
오히려 상호 보완적이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OOP는 모듈화를 통해 도메인 개념을 캡슐화한다.&lt;/li&gt;
&lt;li&gt;AOP는 횡단 관심사를 모듈화하여 코드 중복을 제거한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOP는 OOP만으로는 분리하기 어려운 공통 로직을 흩어지지 않게 모듈화하는 방식이다.
즉, AOP는 OOP의 약점을 보완한다.&lt;/p&gt;
&lt;h3 id="-재미있는-일화"&gt;💡 재미있는 일화
&lt;/h3&gt;&lt;p&gt;Spring 초창기에는 AOP가 XML 설정 기반으로 매우 복잡했지만 지금은 &lt;code&gt;@Aspect&lt;/code&gt; 어노테이션만으로 매우 간단하게 적용할 수 있다.&lt;/p&gt;
&lt;p&gt;JPA 트랜잭션 설정 없이 &lt;code&gt;@Transactional&lt;/code&gt; 하나만 붙였는데도 실제로 프록시 기반으로 트랜잭션이 관리된다는 사실을 알게 되었을 때, 마치 &amp;ldquo;마법 같다&amp;quot;는 반응이 많다.&lt;/p&gt;
&lt;h4 id="spring-aop의-초기-xml-설정의-복잡성"&gt;Spring AOP의 초기 XML 설정의 복잡성
&lt;/h4&gt;&lt;p&gt;Spring AOP의 초기 버전에서는 XML을 통해 AOP 설정을 해야 했다.
예를 들어 &lt;a class="link" href="https://www.digitalocean.com/community/tutorials/spring-aop-example-tutorial-aspect-advice-pointcut-joinpoint-annotations" target="_blank" rel="noopener"
&gt;DigitalOcean의 튜토리얼 - By Pankaj Kumar&lt;/a&gt;에서는 XML 기반 AOP 설정의 예시를 다음과 같이 보여준다.&lt;/p&gt;
&lt;p&gt;이러한 설정은 복잡하고 유지보수가 어려웠겠지.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;aop:config&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;aop:aspect&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;employeeXMLConfigAspect&amp;#34;&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;employeeXMLConfigAspectID&amp;#34;&lt;/span&gt; &lt;span class="na"&gt;order=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;aop:pointcut&lt;/span&gt; &lt;span class="na"&gt;expression=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;execution(* com.journaldev.spring.model.Employee.getName())&amp;#34;&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;getNamePointcut&amp;#34;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;aop:around&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;employeeAroundAdvice&amp;#34;&lt;/span&gt; &lt;span class="na"&gt;pointcut-ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;getNamePointcut&amp;#34;&lt;/span&gt; &lt;span class="na"&gt;arg-names=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;proceedingJoinPoint&amp;#34;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;lt;/aop:aspect&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;&amp;lt;/aop:config&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="transactional-어노테이션과-프록시-기반-트랜잭션-관리의-마법"&gt;&lt;code&gt;@Transactional&lt;/code&gt; 어노테이션과 프록시 기반 트랜잭션 관리의 &amp;ldquo;마법&amp;rdquo;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt; 어노테이션을 사용하면 개발자는 명시적으로 트랜잭션을 시작하거나 종료하는 코드를 작성하지 않아도 된다.&lt;/p&gt;
&lt;p&gt;Spring은 내부적으로 프록시를 생성하여 트랜잭션을 관리한다.
이러한 동작은 개발자에게는 마치 &amp;ldquo;마법&amp;quot;처럼 느껴질 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://www.marcobehler.com/guides/spring-transaction-management-transactional-in-depth" target="_blank" rel="noopener"
&gt;Marco Behler의 블로그&lt;/a&gt;에서는 이러한 동작을 다음과 같이 설명한다.&lt;/p&gt;
&lt;link rel="stylesheet" href="https://b9f1.com/css/vendors/admonitions.5c21d3611305826ca76e50bf22bdda6ed74f2f81d26216e9166f9ae104f2e27a.css" integrity="sha256-XCHTYRMFgmynblC/Ir3abtdPL4HSYhbpFm&amp;#43;a4QTy4no=" crossorigin="anonymous"&gt;
&lt;div class="admonition quote"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"&gt;&lt;path d="M448 296c0 66.3-53.7 120-120 120l-8 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l8 0c30.9 0 56-25.1 56-56l0-8-64 0c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l64 0c35.3 0 64 28.7 64 64l0 32 0 32 0 72zm-256 0c0 66.3-53.7 120-120 120l-8 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l8 0c30.9 0 56-25.1 56-56l0-8-64 0c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l64 0c35.3 0 64 28.7 64 64l0 32 0 32 0 72z"/&gt;&lt;/svg&gt;
&lt;span&gt;Quote&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;&amp;ldquo;Now whenever you are using &lt;code&gt;@Transactional&lt;/code&gt; on a bean, Spring uses a tiny trick. It does not just instantiate a UserService, but also a transactional &lt;em&gt;proxy&lt;/em&gt; of that UserService.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;이제 빈에서 &lt;code&gt;@Transactional&lt;/code&gt;을 사용할 때마다 Spring은 작은 트릭을 사용합니다. 이는 단순히 사용자 서비스를 인스턴스화하는 것뿐만 아니라 해당 사용자 서비스의 트랜잭션 프록시도 사용합니다.&amp;rdquo;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a class="link" href="https://stackoverflow.com/questions/1099025/spring-transactional-what-happens-in-background" target="_blank" rel="noopener"
&gt;Stack Overflow의 질문: Spring - @Transactional - What happens in background?&lt;/a&gt;에서도 이와 유사한 설명을 확인할 수 있었다.
무려 15년 전 질문이다.&lt;/p&gt;
&lt;div class="admonition quote"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"&gt;&lt;path d="M448 296c0 66.3-53.7 120-120 120l-8 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l8 0c30.9 0 56-25.1 56-56l0-8-64 0c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l64 0c35.3 0 64 28.7 64 64l0 32 0 32 0 72zm-256 0c0 66.3-53.7 120-120 120l-8 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l8 0c30.9 0 56-25.1 56-56l0-8-64 0c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l64 0c35.3 0 64 28.7 64 64l0 32 0 32 0 72z"/&gt;&lt;/svg&gt;
&lt;span&gt;Quote&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;&amp;ldquo;But at a very high level, Spring creates proxies for classes that declare &lt;code&gt;@Transactional&lt;/code&gt; on the class itself or on members. The proxy is mostly invisible at runtime. It provides a way for Spring to inject behaviors before, after, or around method calls into the object being proxied.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;매우 높은 수준에서 Spring은 클래스 자체 또는 멤버에 &lt;code&gt;@Transactional&lt;/code&gt;을 선언하는 클래스에 대한 프록시를 생성합니다. 프록시는 런타임에 대부분 보이지 않습니다. 이 프록시는 Spring이 메서드 호출 전후 또는 주변의 동작을 프록시 대상 객체에 주입할 수 있는 방법을 제공합니다.&amp;rdquo;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;&lt;p&gt;OOP는 설계의 뼈대, AOP는 설계의 윤활유다.
AOP는 복잡한 애플리케이션에서 반드시 필요한 설계 전략이다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java 언어 및 Spring Framework 기초&lt;/li&gt;
&lt;li&gt;DI(의존성 주입)과 Proxy 패턴 개념&lt;/li&gt;
&lt;li&gt;어노테이션 기반 설정 이해&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/core/aop.html" target="_blank" rel="noopener"
&gt;Spring AOP 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://eclipse.dev/aspectj/" target="_blank" rel="noopener"
&gt;AspectJ 소개&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;핵심 키워드: &lt;code&gt;@Aspect&lt;/code&gt;, &lt;code&gt;@Around&lt;/code&gt;, &lt;code&gt;JoinPoint&lt;/code&gt;, &lt;code&gt;cross-cutting concern&lt;/code&gt;, &lt;code&gt;Proxy&lt;/code&gt;, &lt;code&gt;Advice&lt;/code&gt;, &lt;code&gt;Pointcut&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>