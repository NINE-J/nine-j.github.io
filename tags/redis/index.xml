<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on B9F1</title><link>https://b9f1.com/tags/redis/</link><description>Recent content in Redis on B9F1</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Oct 2025 17:17:14 +0900</lastBuildDate><atom:link href="https://b9f1.com/tags/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>AWS ECS + ElastiCache Redis 배포</title><link>https://b9f1.com/p/2025-10-16-deploy-elasticache-redis-with-aws-ecs/</link><pubDate>Thu, 16 Oct 2025 17:17:14 +0900</pubDate><guid>https://b9f1.com/p/2025-10-16-deploy-elasticache-redis-with-aws-ecs/</guid><description>&lt;img src="https://b9f1.com/p/2025-10-16-deploy-elasticache-redis-with-aws-ecs/cover.png" alt="Featured image of post AWS ECS + ElastiCache Redis 배포" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;ECS Fargate 기반 분산 환경에서 Redis를 어떻게 배포하고 연결하는지 간단히 정리해본다.&lt;/p&gt;
&lt;p&gt;현재 프로젝트에서는 PostgreSQL(RDS), Kafka(Confluent Cloud)와 함께 Redis를 세션/캐시용으로 운영해야 하는 상황이다.&lt;/p&gt;
&lt;p&gt;Redis를 로컬에서 &lt;code&gt;docker-compose&lt;/code&gt;로 테스트는 했지만 운영 환경에서의 연결 구조와 설정 원리를 명확히 이해하고자 한다.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="redis는-기본-구성만으로-동작한다"&gt;Redis는 기본 구성만으로 동작한다
&lt;/h3&gt;&lt;p&gt;Redis는 HTTP 기반이 아닌 TCP 기반의 Key-Value 서버다.
HTTP처럼 경로 개념이 없고 단순히 정의된 포트(기본 6379)로 열려 있는 소켓을 통해 명령을 주고 받는다.&lt;/p&gt;
&lt;p&gt;즉, Redis는 복잡한 인증이나 핸드셰이크 없이도 클라이언트가 IP와 포트를 알고 있으면 바로 접근 가능한 구조다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis는 &lt;code&gt;host:port&lt;/code&gt; 기반의 TCP 프로토콜만 있으면 동작한다.&lt;/li&gt;
&lt;li&gt;별도의 서비스 레이어가 없으므로 설정의 핵심은 어디로 붙을 것인가.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spring-boot에서-redis-연결-구조"&gt;Spring Boot에서 Redis 연결 구조
&lt;/h3&gt;&lt;p&gt;Spring Boot는 &lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt; 의존성만 추가하면 간단하게 &lt;code&gt;LettuceConnectionFactory&lt;/code&gt;, &lt;code&gt;RedisTemplate&lt;/code&gt;, &lt;code&gt;CacheManager&lt;/code&gt; 등을 등록한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;spring&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;redis-cluster.xxxxxx.apn2.cache.amazonaws.com&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;port&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;6379&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;별도의 Bean을 등록하지 않아도 Spring Boot는 이를 감지해 자동 연결한다.
설정을 생략하면 기본값(&lt;code&gt;localhost:6379&lt;/code&gt;)으로 시도한다.&lt;/p&gt;
&lt;h3 id="elastic-redis-배포-개요"&gt;Elastic Redis 배포 개요
&lt;/h3&gt;&lt;p&gt;AWS에서는 ElastiCache Redis OSS를 사용하면 서버 설치 없이 관리형 Redis 클러스터를 사용할 수 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구성 요소&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Primary Node&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;쓰기 담당 Redis 노드&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Replica Node&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;읽기 전용 복제본 (선택사항)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Cluster&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;여러 샤드로 데이터를 분산 저장&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Endpoint&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;연결용 주소 (&lt;code&gt;.cache.amazonaws.com&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="ecs-fargate-연결-구조"&gt;ECS Fargate 연결 구조
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;보안 그룹 규칙&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Inbound: 6379 허용 (ECS -&amp;gt; Redis)&lt;/li&gt;
&lt;li&gt;Outbound: ECS에서 Redis SG(Security Group)로 접근 허용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;: 같은 VPC 또는 피어링된 네트워크에 존재해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="로컬-docker와-운영-redis의-관계"&gt;로컬 Docker와 운영 Redis의 관계
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구분&lt;/th&gt;
&lt;th&gt;로컬 환경&lt;/th&gt;
&lt;th&gt;운영 환경&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;호스트&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;localhost:6379&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Elasticache Endpoint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;목적&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;개발 및 단위 테스트&lt;/td&gt;
&lt;td&gt;실제 서비스 운영&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;공유 여부&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;완전히 분리&lt;/td&gt;
&lt;td&gt;완전히 분리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;차이점&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;단일 인스턴스&lt;/td&gt;
&lt;td&gt;멀티 AZ, 클러스터링, 모니터링 제공&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;즉, 코드상으로는 동일한 RedisTemplate을 사용하지만 환경 변수(&lt;code&gt;SPRING_DATA_REDIS_HOST&lt;/code&gt;, &lt;code&gt;SPRING_DATA_REDIS_PORT&lt;/code&gt;)만 달라진다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;호스트와 포트를 맞추어&lt;/strong&gt; TCP 레벨에서 연결만 되면 Redis는 별도 복잡한 설정 없이 바로 동작한다.&lt;/p&gt;
&lt;h3 id="운영-시-고려사항"&gt;운영 시 고려사항
&lt;/h3&gt;&lt;p&gt;운영 환경에서는 다음 항목들을 통해 &lt;strong&gt;보안과 안정성을 강화&lt;/strong&gt;할 수 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구분&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;보안 그룹 제한&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Redis 포트(6379)는 오직 ECS 서비스의 보안 그룹에서만 접근 가능하도록 설정한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;VPC 내부 통신&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;퍼블릭 액세스를 비활성화하고, VPC 내부 트래픽으로만 접근을 제한한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;암호화 옵션&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Elasticache 생성 시 ‘전송 중 암호화(Encryption in-transit)’ 및 ‘저장 시 암호화(Encryption at-rest)’를 활성화한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Redis AUTH (선택)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;OSS 기본은 인증 미지원이지만, 필요 시 Redis Enterprise 또는 프록시 계층을 통해 비밀번호 인증을 구성할 수 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;세션 공유 설정&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Spring Boot 세션 스토어를 Redis로 변경 (&lt;code&gt;spring.session.store-type=redis&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TTL 관리&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;캐시 만료시간을 반드시 설정 (&lt;code&gt;Duration.ofMinutes(...)&lt;/code&gt; 등).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;모니터링&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;CloudWatch, Redis SlowLog, CloudWatch Metrics 등을 활용해 지표와 성능을 추적한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;&lt;p&gt;Redis는 기본적으로 포트만 맞으면 동작하지만,&lt;br&gt;
운영 환경에서는 &lt;strong&gt;보안 그룹, VPC, 암호화 옵션&lt;/strong&gt;을 통해 최소한의 방어선을 만들 수 있다.&lt;/p&gt;
&lt;p&gt;Spring Boot에서는 host와 port만 지정하면 자동으로 연결되고 Elasticache Redis는 이를 VPC 내부에서 안전하게 관리해준다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;AWS ECS / VPC / Security Group 개념&lt;/li&gt;
&lt;li&gt;Redis Key-Value 구조 및 기본 명령&lt;/li&gt;
&lt;li&gt;Spring Boot 자동 설정 (&lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://aws.amazon.com/ko/elasticache/redis/" target="_blank" rel="noopener"
&gt;Redis OSS 호환 Amazon ElastiCache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.spring.io/spring-data/redis/reference/" target="_blank" rel="noopener"
&gt;Spring Data Redis Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://redis.io/docs/latest/develop/reference/protocol-spec/" target="_blank" rel="noopener"
&gt;Redis serialization protocol specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/vpc-peering.html" target="_blank" rel="noopener"
&gt;VPC 피어링을 사용하여 VPC 연결&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://devoong2.tistory.com/entry/Kafka-%EC%99%80-Redis-%EC%9D%98-PubSub-%EB%B9%84%EA%B5%90" target="_blank" rel="noopener"
&gt;Kafka 와 Redis 의 Pub/Sub 비교&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>로컬 캐시 vs 분산 캐시</title><link>https://b9f1.com/p/2025-08-30-local-cache-vs-distributed-cache/</link><pubDate>Sat, 30 Aug 2025 13:25:20 +0900</pubDate><guid>https://b9f1.com/p/2025-08-30-local-cache-vs-distributed-cache/</guid><description>&lt;img src="https://b9f1.com/p/2025-08-30-local-cache-vs-distributed-cache/cover.png" alt="Featured image of post 로컬 캐시 vs 분산 캐시" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;애플리케이션의 성능 최적화에서 &lt;strong&gt;캐시(Cache)&lt;/strong&gt; 는 빠질 수 없는 핵심 요소다.&lt;/p&gt;
&lt;p&gt;캐시는 데이터를 반복적으로 계산하거나 DB에서 가져오지 않고, &lt;strong&gt;빠른 접근이 가능한 저장소&lt;/strong&gt;에 보관해 재사용함으로써 응답 속도를 개선한다.&lt;/p&gt;
&lt;p&gt;이번 글에서는 &lt;strong&gt;로컬 캐시(Local Cache)&lt;/strong&gt; 와 &lt;strong&gt;분산 캐시(Distributed Cache)&lt;/strong&gt; 의 개념적 차이를 살펴보고, 각각의 장단점, 그리고 실무에서 어떤 기준으로 선택해야 하는지 다룬다.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="1-로컬-캐시local-cache"&gt;1. 로컬 캐시(Local Cache)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 애플리케이션 프로세스 내부 메모리에 데이터를 저장하는 캐시.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;: Spring Boot에서 &lt;code&gt;@Cacheable&lt;/code&gt;과 함께 사용하는 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;, Guava Cache, Caffeine 등.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="장점"&gt;장점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DB나 네트워크를 거치지 않고 &lt;strong&gt;메모리 접근 속도&lt;/strong&gt;로 응답 → 극한의 성능.&lt;/li&gt;
&lt;li&gt;설치나 운영이 간단하며, 외부 시스템 의존도가 없음.&lt;/li&gt;
&lt;li&gt;트래픽이 적거나 단일 서버 애플리케이션에 적합.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="단점"&gt;단점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;확장성 부족&lt;/strong&gt;: 서버가 여러 대라면 각 인스턴스마다 캐시를 따로 관리해야 함 → 데이터 불일치(Inconsistency).&lt;/li&gt;
&lt;li&gt;서버 재시작 시 캐시 데이터 손실.&lt;/li&gt;
&lt;li&gt;캐시 메모리 크기가 서버 메모리에 직접 의존.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-분산-캐시distributed-cache"&gt;2. 분산 캐시(Distributed Cache)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 네트워크를 통해 여러 애플리케이션 인스턴스가 공유하는 외부 캐시 서버.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;: Redis, Memcached, Hazelcast, AWS ElastiCache.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="장점-1"&gt;장점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;여러 서버 간 &lt;strong&gt;캐시 일관성 보장&lt;/strong&gt; (모든 노드가 같은 캐시 데이터 참조).&lt;/li&gt;
&lt;li&gt;서버 재시작에도 데이터 유지 가능(특히 Redis 같은 Persistent Cache).&lt;/li&gt;
&lt;li&gt;대규모 트래픽 처리와 수평 확장에 적합.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="단점-1"&gt;단점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;네트워크를 거치므로 로컬 캐시보다 접근 속도는 느림.&lt;/li&gt;
&lt;li&gt;별도의 인프라 운영이 필요하며, 설정 및 비용 부담이 있음.&lt;/li&gt;
&lt;li&gt;네트워크 장애 시 캐시 미스(cache miss) 폭발 가능성.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-실무에서의-선택-기준"&gt;3. 실무에서의 선택 기준
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기준&lt;/th&gt;
&lt;th&gt;로컬 캐시 적합&lt;/th&gt;
&lt;th&gt;분산 캐시 적합&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;트래픽 규모&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;소규모, 단일 서버&lt;/td&gt;
&lt;td&gt;대규모, 다중 서버&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;일관성 요구&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;데이터 변동이 적거나 중요하지 않은 경우&lt;/td&gt;
&lt;td&gt;강한 일관성이 필요한 경우&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;운영 복잡도&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;간단한 아키텍처 추구&lt;/td&gt;
&lt;td&gt;별도 인프라 운영 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;마이크로초 단위 응답&lt;/td&gt;
&lt;td&gt;밀리초 단위 응답 (네트워크 오버헤드)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;장애 복원력&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;서버 재시작 시 캐시 유실&lt;/td&gt;
&lt;td&gt;영속성 옵션을 통해 데이터 유지 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;보통 &lt;strong&gt;초기 단계&lt;/strong&gt;에서는 로컬 캐시(Caffeine 등)로 간단히 시작하고, 트래픽이 증가해 서버를 여러 대 띄우는 순간 &lt;strong&gt;분산 캐시(Redis)&lt;/strong&gt; 로 전환하는 전략이 가장 합리적이다.&lt;/p&gt;
&lt;p&gt;실제로 Spring에서도 &lt;code&gt;@Cacheable&lt;/code&gt; 같은 어노테이션은 캐시 추상화를 제공해 &lt;strong&gt;로컬 ↔ 분산 캐시 전환이 용이&lt;/strong&gt;하도록 설계되어 있다.&lt;/p&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"&gt;&lt;path d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"/&gt;&lt;/svg&gt;
&lt;span&gt;Tip&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;지금 운영하는 서비스는 “속도”가 중요한가, “규모와 일관성”이 중요한가?&lt;/p&gt;
&lt;p&gt;이 질문에 대한 답이 로컬 vs 분산 캐시 선택의 시작점이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;프로젝트 초반에는 로컬 캐시로 충분하다. 그러나 &lt;strong&gt;트래픽 증가·수평 확장·데이터 일관성 요구&lt;/strong&gt;가 생기는 순간 분산 캐시로 전환해야 한다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;캐시의 기본 동작 원리 (Cache Hit / Cache Miss)&lt;/li&gt;
&lt;li&gt;Spring Cache 추상화 (&lt;code&gt;@Cacheable&lt;/code&gt;, &lt;code&gt;@CachePut&lt;/code&gt;, &lt;code&gt;@CacheEvict&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Redis, Memcached 같은 인메모리 DB의 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/integration/cache.html" target="_blank" rel="noopener"
&gt;Spring Framework Docs - Caching Abstraction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://redis.io/docs/" target="_blank" rel="noopener"
&gt;Redis 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener"
&gt;Caffeine Cache GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PostgreSQL의 캐시 활용 및 쿼리 최적화&lt;/li&gt;
&lt;li&gt;AWS ElastiCache&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>