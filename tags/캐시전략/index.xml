<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>캐시전략 on B9F1</title><link>https://b9f1.com/tags/%EC%BA%90%EC%8B%9C%EC%A0%84%EB%9E%B5/</link><description>Recent content in 캐시전략 on B9F1</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 Aug 2025 13:25:20 +0900</lastBuildDate><atom:link href="https://b9f1.com/tags/%EC%BA%90%EC%8B%9C%EC%A0%84%EB%9E%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>로컬 캐시 vs 분산 캐시</title><link>https://b9f1.com/p/2025-08-30-local-cache-vs-distributed-cache/</link><pubDate>Sat, 30 Aug 2025 13:25:20 +0900</pubDate><guid>https://b9f1.com/p/2025-08-30-local-cache-vs-distributed-cache/</guid><description>&lt;img src="https://b9f1.com/p/2025-08-30-local-cache-vs-distributed-cache/cover.png" alt="Featured image of post 로컬 캐시 vs 분산 캐시" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;애플리케이션의 성능 최적화에서 &lt;strong&gt;캐시(Cache)&lt;/strong&gt; 는 빠질 수 없는 핵심 요소다.&lt;/p&gt;
&lt;p&gt;캐시는 데이터를 반복적으로 계산하거나 DB에서 가져오지 않고, &lt;strong&gt;빠른 접근이 가능한 저장소&lt;/strong&gt;에 보관해 재사용함으로써 응답 속도를 개선한다.&lt;/p&gt;
&lt;p&gt;이번 글에서는 &lt;strong&gt;로컬 캐시(Local Cache)&lt;/strong&gt; 와 &lt;strong&gt;분산 캐시(Distributed Cache)&lt;/strong&gt; 의 개념적 차이를 살펴보고, 각각의 장단점, 그리고 실무에서 어떤 기준으로 선택해야 하는지 다룬다.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="1-로컬-캐시local-cache"&gt;1. 로컬 캐시(Local Cache)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 애플리케이션 프로세스 내부 메모리에 데이터를 저장하는 캐시.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;: Spring Boot에서 &lt;code&gt;@Cacheable&lt;/code&gt;과 함께 사용하는 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;, Guava Cache, Caffeine 등.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="장점"&gt;장점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DB나 네트워크를 거치지 않고 &lt;strong&gt;메모리 접근 속도&lt;/strong&gt;로 응답 → 극한의 성능.&lt;/li&gt;
&lt;li&gt;설치나 운영이 간단하며, 외부 시스템 의존도가 없음.&lt;/li&gt;
&lt;li&gt;트래픽이 적거나 단일 서버 애플리케이션에 적합.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="단점"&gt;단점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;확장성 부족&lt;/strong&gt;: 서버가 여러 대라면 각 인스턴스마다 캐시를 따로 관리해야 함 → 데이터 불일치(Inconsistency).&lt;/li&gt;
&lt;li&gt;서버 재시작 시 캐시 데이터 손실.&lt;/li&gt;
&lt;li&gt;캐시 메모리 크기가 서버 메모리에 직접 의존.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-분산-캐시distributed-cache"&gt;2. 분산 캐시(Distributed Cache)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정의&lt;/strong&gt;: 네트워크를 통해 여러 애플리케이션 인스턴스가 공유하는 외부 캐시 서버.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시&lt;/strong&gt;: Redis, Memcached, Hazelcast, AWS ElastiCache.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="장점-1"&gt;장점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;여러 서버 간 &lt;strong&gt;캐시 일관성 보장&lt;/strong&gt; (모든 노드가 같은 캐시 데이터 참조).&lt;/li&gt;
&lt;li&gt;서버 재시작에도 데이터 유지 가능(특히 Redis 같은 Persistent Cache).&lt;/li&gt;
&lt;li&gt;대규모 트래픽 처리와 수평 확장에 적합.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="단점-1"&gt;단점
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;네트워크를 거치므로 로컬 캐시보다 접근 속도는 느림.&lt;/li&gt;
&lt;li&gt;별도의 인프라 운영이 필요하며, 설정 및 비용 부담이 있음.&lt;/li&gt;
&lt;li&gt;네트워크 장애 시 캐시 미스(cache miss) 폭발 가능성.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-실무에서의-선택-기준"&gt;3. 실무에서의 선택 기준
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기준&lt;/th&gt;
&lt;th&gt;로컬 캐시 적합&lt;/th&gt;
&lt;th&gt;분산 캐시 적합&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;트래픽 규모&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;소규모, 단일 서버&lt;/td&gt;
&lt;td&gt;대규모, 다중 서버&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;일관성 요구&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;데이터 변동이 적거나 중요하지 않은 경우&lt;/td&gt;
&lt;td&gt;강한 일관성이 필요한 경우&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;운영 복잡도&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;간단한 아키텍처 추구&lt;/td&gt;
&lt;td&gt;별도 인프라 운영 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;마이크로초 단위 응답&lt;/td&gt;
&lt;td&gt;밀리초 단위 응답 (네트워크 오버헤드)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;장애 복원력&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;서버 재시작 시 캐시 유실&lt;/td&gt;
&lt;td&gt;영속성 옵션을 통해 데이터 유지 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;보통 &lt;strong&gt;초기 단계&lt;/strong&gt;에서는 로컬 캐시(Caffeine 등)로 간단히 시작하고, 트래픽이 증가해 서버를 여러 대 띄우는 순간 &lt;strong&gt;분산 캐시(Redis)&lt;/strong&gt; 로 전환하는 전략이 가장 합리적이다.&lt;/p&gt;
&lt;p&gt;실제로 Spring에서도 &lt;code&gt;@Cacheable&lt;/code&gt; 같은 어노테이션은 캐시 추상화를 제공해 &lt;strong&gt;로컬 ↔ 분산 캐시 전환이 용이&lt;/strong&gt;하도록 설계되어 있다.&lt;/p&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"&gt;&lt;path d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"/&gt;&lt;/svg&gt;
&lt;span&gt;Tip&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;지금 운영하는 서비스는 “속도”가 중요한가, “규모와 일관성”이 중요한가?&lt;/p&gt;
&lt;p&gt;이 질문에 대한 답이 로컬 vs 분산 캐시 선택의 시작점이다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;프로젝트 초반에는 로컬 캐시로 충분하다. 그러나 &lt;strong&gt;트래픽 증가·수평 확장·데이터 일관성 요구&lt;/strong&gt;가 생기는 순간 분산 캐시로 전환해야 한다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;캐시의 기본 동작 원리 (Cache Hit / Cache Miss)&lt;/li&gt;
&lt;li&gt;Spring Cache 추상화 (&lt;code&gt;@Cacheable&lt;/code&gt;, &lt;code&gt;@CachePut&lt;/code&gt;, &lt;code&gt;@CacheEvict&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Redis, Memcached 같은 인메모리 DB의 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/integration/cache.html" target="_blank" rel="noopener"
&gt;Spring Framework Docs - Caching Abstraction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://redis.io/docs/" target="_blank" rel="noopener"
&gt;Redis 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener"
&gt;Caffeine Cache GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PostgreSQL의 캐시 활용 및 쿼리 최적화&lt;/li&gt;
&lt;li&gt;AWS ElastiCache&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Spring Cache 핵심 어노테이션 정리</title><link>https://b9f1.com/p/2025-08-30-spring-cache-core-annotation/</link><pubDate>Sat, 30 Aug 2025 13:12:30 +0900</pubDate><guid>https://b9f1.com/p/2025-08-30-spring-cache-core-annotation/</guid><description>&lt;img src="https://b9f1.com/p/2025-08-30-spring-cache-core-annotation/cover.png" alt="Featured image of post Spring Cache 핵심 어노테이션 정리" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;Spring Framework에서 캐싱은 데이터베이스 조회나 외부 API 호출처럼 &lt;strong&gt;비용이 큰 연산 결과를 저장&lt;/strong&gt;해두고 재사용할 수 있게 도와준다.&lt;/p&gt;
&lt;p&gt;이를 간단히 적용할 수 있는 방법이 바로 &lt;strong&gt;Spring Cache 어노테이션&lt;/strong&gt;(&lt;code&gt;@Cacheable&lt;/code&gt;, &lt;code&gt;@CachePut&lt;/code&gt;, &lt;code&gt;@CacheEvict&lt;/code&gt;)이다.&lt;/p&gt;
&lt;p&gt;이 세 가지 어노테이션의 차이점과 각각을 언제 사용하는 게 좋은지 정리한다.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="1-cacheable"&gt;1. @Cacheable
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;: 캐시에 값이 있으면 그대로 반환하고, 없으면 메서드를 실행 후 결과를 캐시에 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;적절한 상황&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;조회 성능 최적화가 필요한 경우 (DB 조회, 외부 API 호출)&lt;/li&gt;
&lt;li&gt;결과가 자주 변하지 않고 재사용 가치가 큰 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시 코드&lt;/strong&gt;:
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@Cacheable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cacheNames&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;books&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;#isbn&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;findBook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isbn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-cacheput"&gt;2. @CachePut
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;: 항상 메서드를 실행하고, 실행 결과를 캐시에 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;적절한 상황&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;업데이트가 발생했을 때 최신 결과를 캐시에 반영해야 할 때&lt;/li&gt;
&lt;li&gt;캐시 미스를 줄이기보다 캐시 동기화가 중요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;주의점&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Cacheable&lt;/code&gt;과 같은 메서드에 함께 사용하는 것은 비추천 (동작 충돌 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시 코드&lt;/strong&gt;:
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@CachePut&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cacheNames&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;books&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;#isbn&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;updateBook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isbn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BookDescriptor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;descriptor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-cacheevict"&gt;3. @CacheEvict
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동작 방식&lt;/strong&gt;: 캐시에서 특정 엔트리나 전체 엔트리를 제거한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;적절한 상황&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;데이터 삭제/갱신 후, 오래된 캐시를 반드시 무효화해야 할 때&lt;/li&gt;
&lt;li&gt;정기적으로 캐시를 초기화할 때&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;옵션&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allEntries = true&lt;/code&gt;: 캐시 전체 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beforeInvocation = true&lt;/code&gt;: 메서드 실행 전 캐시 삭제 (예외 발생 시에도 캐시 정리 보장)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;예시 코드&lt;/strong&gt;:
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@CacheEvict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cacheNames&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;books&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;#isbn&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;deleteBook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isbn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="nd"&gt;@CacheEvict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cacheNames&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;books&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;allEntries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;clearCache&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;조회는 &lt;code&gt;@Cacheable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;갱신은 &lt;code&gt;@CachePut&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;삭제/무효화는 &lt;code&gt;@CacheEvict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 세 가지를 상황에 맞게 조합하면, DB 부하를 줄이면서도 데이터 정합성을 유지하는 효율적인 캐싱 전략을 설계할 수 있다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java, Spring Boot 애플리케이션 기본 구조&lt;/li&gt;
&lt;li&gt;캐시(Cache)의 개념과 동작 원리&lt;/li&gt;
&lt;li&gt;Redis, Caffeine 등 Spring Cache 지원 캐시 제공자&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/integration/cache.html" target="_blank" rel="noopener"
&gt;Spring Framework Docs - Caching Abstraction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://redis.io/docs/" target="_blank" rel="noopener"
&gt;Redis 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Spring Boot Reference: &lt;code&gt;spring-boot-starter-cache&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>