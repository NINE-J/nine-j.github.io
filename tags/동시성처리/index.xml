<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>동시성처리 on B9F1</title><link>https://b9f1.com/tags/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%B2%98%EB%A6%AC/</link><description>Recent content in 동시성처리 on B9F1</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 16 Aug 2025 00:00:00 +0900</lastBuildDate><atom:link href="https://b9f1.com/tags/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%B2%98%EB%A6%AC/index.xml" rel="self" type="application/rss+xml"/><item><title>Race condition 뿌리부터 잡기</title><link>https://b9f1.com/p/2025-08-16-from-the-basics-of-race-condition/</link><pubDate>Sat, 16 Aug 2025 00:00:00 +0900</pubDate><guid>https://b9f1.com/p/2025-08-16-from-the-basics-of-race-condition/</guid><description>&lt;img src="https://b9f1.com/p/2025-08-16-from-the-basics-of-race-condition/cover.png" alt="Featured image of post Race condition 뿌리부터 잡기" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;트래픽이 두 배가 되는 순간, 가장 먼저 터지는 건 &lt;strong&gt;성능&lt;/strong&gt;이 아니라 &lt;strong&gt;정합성&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;멀티스레드 환경의 대표적 복병 &lt;strong&gt;경쟁 상태(Race Condition)&lt;/strong&gt; 는 재현도 어렵고 한 번 새면 데이터 신뢰도가 무너진다.&lt;/p&gt;
&lt;p&gt;운영 환경에서 빈번하게 마주치는 &lt;strong&gt;경쟁 상태의 원인&lt;/strong&gt;, &lt;strong&gt;재현 패턴&lt;/strong&gt;, &lt;strong&gt;해결 전략의 우선순위&lt;/strong&gt;를 정리한다.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="경쟁-상태란-무엇인가"&gt;경쟁 상태란 무엇인가?
&lt;/h3&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;정의&lt;br&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;여러 스레드가 &lt;strong&gt;공유 상태(shared state)&lt;/strong&gt; 를 동시에 읽고/쓰기 하며 실행 타이밍에 따라 결과가 달라지는 상황.&lt;br&gt;
핵심 원인 축: &lt;strong&gt;AVR&lt;/strong&gt; - Atomicity(원자성), Visibility(가시성), Reordering(재배치).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Atomicity&lt;/strong&gt;: &lt;code&gt;x = x + 1&lt;/code&gt; 같은 RMW(Read–Modify–Write) 연산이 중간에 끼어들기로 깨지면서 lost update 발생&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visibility&lt;/strong&gt;: 한 스레드의 쓰기가 다른 스레드에 늦게 보여 stale value(오래된 값) 관측, 잘못된 분기
&lt;ul&gt;
&lt;li&gt;stale value: 다른 스레드가 최신 값을 썼음에도 불구하고, 캐시/레지스터 등 중간 계층에 남아있던 &lt;strong&gt;이전 값&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이 때문에 &lt;strong&gt;중복 및 누락&lt;/strong&gt;뿐 아니라 &lt;code&gt;if (value==0)&lt;/code&gt; 같은 &lt;strong&gt;조건 분기 오류&lt;/strong&gt;가 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reordering&lt;/strong&gt;: CPU out-of-order 실행이나 JIT 최적화로 happens-before 순서가 무너짐&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="위험-신호와-재현-패턴"&gt;위험 신호와 재현 패턴
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;증상&lt;/strong&gt;: 카운터 불일치, 중복/누락, “가끔” 실패하는 테스트, 운영 환경에서만 나타나는 버그(Heisenbug)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;패턴&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if(없으면 저장)&lt;/code&gt; 후 put (TOCTOU)&lt;/li&gt;
&lt;li&gt;캐시 초기화 동시 접근&lt;/li&gt;
&lt;li&gt;통계 카운터 증가&lt;/li&gt;
&lt;li&gt;잘못된 Lazy init&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;Heisenbug&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;하이젠버그는 프로그래밍에서 테스트를 수행할 때 발생되는 버그의 형태 중의 하나로서 문제를 발견하고 수정하기 위한 디버깅을 수행하려고 하면 문제점이 사라지는 형태의 버그를 말한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;TOCTOU (Time Of Check to Time Of Use)&lt;br&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;검사 시점과 사용 시점 사이의 틈새에서 다른 스레드가 상태를 바꿔 &lt;strong&gt;예상치 못한 버그 및 보안 취약점&lt;/strong&gt;을 유발하는 &lt;strong&gt;클래식 경쟁 조건 유형&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="최소-예제로-보는-버그"&gt;최소 예제로 보는 버그
&lt;/h3&gt;
&lt;div class="admonition warning"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"/&gt;&lt;/svg&gt;
&lt;span&gt;원자적이지 않은 연산&lt;br&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;&lt;code&gt;value++&lt;/code&gt; 는 단일 연산처럼 보이지만, JVM 바이트코드 레벨에서는 &lt;code&gt;getfield&lt;/code&gt; → &lt;code&gt;iconst_1&lt;/code&gt; → &lt;code&gt;iadd&lt;/code&gt; → &lt;code&gt;putfield&lt;/code&gt; 로 분해된다.
중간에 다른 스레드가 끼어들어 lost update 발생. &lt;code&gt;volatile&lt;/code&gt;은 가시성만 보장해도 원자성은 보장 못 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BrokenCounter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 경쟁 상태&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="바이트코드-관점필드-증가"&gt;바이트코드 관점(필드 증가)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getfield value&lt;/code&gt; → &lt;code&gt;iconst_1&lt;/code&gt; → &lt;code&gt;iadd&lt;/code&gt; → &lt;code&gt;putfield value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;단일 연산이 아니라 여러 명령어로 분해됨 → 원자성 깨짐&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="interleaving-예-두-스레드"&gt;Interleaving 예 (두 스레드)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;두 번 증가 의도 → 최종 값 1 (한 번만 반영)&lt;/li&gt;
&lt;li&gt;DB의 &lt;strong&gt;Lost Update anomaly&lt;/strong&gt;와 동일한 문제&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="가시성까지-얽히면-더-위험"&gt;가시성까지 얽히면 더 위험
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A 스레드가 &lt;code&gt;1&lt;/code&gt; 저장해도, B 스레드는 캐시 coherence 지연으로 여전히 &lt;code&gt;0&lt;/code&gt;(stale value) 관측&lt;/li&gt;
&lt;li&gt;결과:
&lt;ol&gt;
&lt;li&gt;카운터 중복·누락&lt;/li&gt;
&lt;li&gt;조건 분기 오류 (예: &lt;code&gt;if (get()==0) init()&lt;/code&gt;이 중복 실행)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="왜-volatile로-해결되지-않나"&gt;왜 &lt;code&gt;volatile&lt;/code&gt;로 해결되지 않나?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;은 가시성(Visibility)과 재배치(Reordering) 방지 일부를 보장한다.&lt;/li&gt;
&lt;li&gt;하지만 &lt;code&gt;value++&lt;/code&gt; 같은 RMW 원자성은 보장 못 함&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;volatile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 여전히 lost update 가능&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="해결-전략-락보다-설계가-먼저"&gt;해결 전략: 락보다 설계가 먼저
&lt;/h3&gt;&lt;h4 id="상태-자체를-줄여라"&gt;상태 자체를 줄여라
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;불변 객체(Immutable), Copy-on-Write, 메시지 패싱/Actor 모델, 이벤트 루프&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="스레드-컨파인먼트"&gt;스레드 컨파인먼트
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;, 키 파티셔닝(같은 키는 동일 워커로)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="원자-연산--동시-컬렉션-juc"&gt;원자 연산 &amp;amp; 동시 컬렉션 (J.U.C)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AtomicInteger.incrementAndGet()&lt;/code&gt; (CAS 기반)
&lt;ul&gt;
&lt;li&gt;CAS(Compare-And-Swap)는 &lt;strong&gt;재시도 루프(spin)&lt;/strong&gt; 구조로 동작한다. 즉, 경쟁이 심하면 충돌이 잦아지고 성능이 급격히 저하될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;고경합 환경엔 &lt;code&gt;LongAdder&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;내부적으로 셀(Cell) 배열에 분산 저장하여 스레드 충돌을 줄인다.&lt;/li&gt;
&lt;li&gt;주기적 집계를 통해 최종 값을 계산 → CAS 충돌 병목이 적음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap.computeIfAbsent/merge&lt;/code&gt;로 TOCTOU 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;CAS와 성능&lt;br&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;CAS는 실패 시 루프를 돌며 재시도하는 &lt;strong&gt;spin 기반 알고리즘&lt;/strong&gt;이다.
경쟁이 적을 땐 락보다 빠르지만, 경쟁이 많으면 계속 충돌 → 재시도로 인해 오히려 락보다 느려질 수 있다.
이 때문에 고경합 상황에서는 &lt;code&gt;LongAdder&lt;/code&gt; 같은 분산 구조가 더 유리하다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="동기화-synchronization"&gt;동기화 (Synchronization)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; (간단, 확실)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; (tryLock, 타임아웃 지원)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;, &lt;code&gt;StampedLock&lt;/code&gt; (낙관적 읽기 성능 개선)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StampedLock&lt;/code&gt;의 &lt;strong&gt;낙관적 읽기&lt;/strong&gt;는 실제 읽은 값이 도중에 다른 쓰기에 의해 깨지지 않았는지 &lt;code&gt;validate(stamp)&lt;/code&gt; 호출로 반드시 검증해야 안전하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/&gt;&lt;/svg&gt;
&lt;span&gt;StampedLock의 validate()&lt;br&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;&lt;code&gt;long stamp = lock.tryOptimisticRead();&lt;/code&gt; → 값 읽기 → &lt;code&gt;if (!lock.validate(stamp)) { ...재시도... }&lt;/code&gt;
낙관적 읽기는 무조건 성공하는 게 아니라, 읽은 후에 검증(validate)을 반드시 거쳐야 한다. 검증이 실패하면 일반적인 읽기 락을 다시 걸어야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="가시성-보장--안전한-게시"&gt;가시성 보장 &amp;amp; 안전한 게시
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 플래그, &lt;code&gt;final&lt;/code&gt; 필드&lt;/li&gt;
&lt;li&gt;Safe Publication (동기화 통해 객체를 게시)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="단일-실행--멱등idempotency"&gt;단일 실행 &amp;amp; 멱등(Idempotency)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;멱등 설계, fencing token(순서 보장 토큰)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="실전-시나리오별-추천-레시피"&gt;실전 시나리오별 추천 레시피
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;시나리오&lt;/th&gt;
&lt;th&gt;증상&lt;/th&gt;
&lt;th&gt;해법&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동시 카운팅/지표&lt;/td&gt;
&lt;td&gt;증발(Lost update)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;LongAdder&lt;/code&gt; → 주기적 집계&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lazy 초기화&lt;/td&gt;
&lt;td&gt;중복 생성&lt;/td&gt;
&lt;td&gt;&lt;code&gt;computeIfAbsent&lt;/code&gt;, 초기화 전용 락&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;캐시 프리로드&lt;/td&gt;
&lt;td&gt;중복 로드&lt;/td&gt;
&lt;td&gt;키 파티셔닝 + 단일 워커&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;읽기 99%&lt;/td&gt;
&lt;td&gt;락 경합&lt;/td&gt;
&lt;td&gt;Copy-on-Write, &lt;code&gt;StampedLock&lt;/code&gt; 낙관 읽기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;고가 연산 임계구역&lt;/td&gt;
&lt;td&gt;응답 지연&lt;/td&gt;
&lt;td&gt;임계구역 축소, 분해락(키별 락)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;키 충돌 업데이트&lt;/td&gt;
&lt;td&gt;중복·경합&lt;/td&gt;
&lt;td&gt;키별 락/Striped Lock, &lt;code&gt;merge&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="성능-vs-정확성-트레이드오프"&gt;성능 vs 정확성 트레이드오프
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;정확성 고정&lt;/strong&gt;: &lt;code&gt;synchronized&lt;/code&gt;/ConcurrentHashMap으로 정합성 우선 확보&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;핫스팟 튜닝&lt;/strong&gt;: 임계구역 축소, 자료구조 교체&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;마지막에&lt;/strong&gt;: 락-프리/낙관적 기법 적용&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="테스트검증-전략"&gt;테스트·검증 전략
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;jcstress&lt;/strong&gt; (OpenJDK 동시성 경계 테스트 프레임워크)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;확률 테스트&lt;/strong&gt; (스레드 수·코어 수·JVM 옵션 다양화)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;페일패스트 계측&lt;/strong&gt; (불가능 상태 assert)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;장시간 soak test&lt;/strong&gt; (운영 유사 환경)&lt;/li&gt;
&lt;li&gt;이런 버그는 &lt;strong&gt;Heisenbug&lt;/strong&gt; 특성이 강함 → 반드시 장기간·다양 환경에서 검증 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;공유 상태를 최소화하라.&lt;/strong&gt;
남는 공유 상태는 반드시 &lt;strong&gt;J.U.C(java.util.concurrent)&lt;/strong&gt; 와 &lt;strong&gt;명시적 동기화&lt;/strong&gt;로 보호하라.
먼저 정합성을 보장하고, 이후 성능을 최적화하는 순서가 바람직하다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java Memory Model(JMM), happens-before&lt;/li&gt;
&lt;li&gt;monitor/synchronized, CAS(compare-and-swap)&lt;/li&gt;
&lt;li&gt;J.U.C(java.util.concurrent): 원자 클래스, 동시 컬렉션&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java Concurrency in Practice (Brian Goetz)&lt;/li&gt;
&lt;li&gt;Effective Java 동시성 아이템&lt;/li&gt;
&lt;li&gt;OpenJDK &lt;strong&gt;jcstress&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Oracle Concurrency 튜토리얼&lt;/li&gt;
&lt;li&gt;Martin Kleppmann: Idempotency / Exactly-once&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>트랜잭션 격리성 - Isolation</title><link>https://b9f1.com/p/2025-06-15-db-what-happens-when-transaction-isolation-collapses/</link><pubDate>Sun, 15 Jun 2025 17:31:13 +0900</pubDate><guid>https://b9f1.com/p/2025-06-15-db-what-happens-when-transaction-isolation-collapses/</guid><description>&lt;img src="https://b9f1.com/p/2025-06-15-db-what-happens-when-transaction-isolation-collapses/cover.png" alt="Featured image of post 트랜잭션 격리성 - Isolation" /&gt;&lt;h2 id="개요"&gt;📌개요
&lt;/h2&gt;&lt;p&gt;트랜잭션의 ACID 속성 중 &lt;strong&gt;Isolcation(격리성)&lt;/strong&gt; 은 다수의 트랜잭션이 동시에 실행될 때 각 트랜잭션이 서로에게 미치는 영향을 통제하기 위한 핵심 요소이며 가장 복잡하고 이해하기 어려운 속성이다.&lt;/p&gt;
&lt;p&gt;격리 수준이 보장하는 것은 단순히 일관성이 아니라 &lt;strong&gt;데이터 무결성과 비즈니스의 신뢰성&lt;/strong&gt; 이다.
특히 동시성 환경에서 격리 수준이 부족하면 데이터는 꼬이고, 그 피해는 실시간으로 사용자에게 전달된다.&lt;/p&gt;
&lt;p&gt;이번 글에서 정리하는 건 모두 이해하고 작성할 수 없어서 관련 자료를 정리한 후 상세한 내용에 대해 더 깊게 파고들 예정이다.&lt;/p&gt;
&lt;p&gt;격리성이 무너지면서 발생하는 문제들을 예제로 설명하고, 이를 막기 위해 존재하는 격리 수준들에 대해 단계적으로 정리해본다.&lt;/p&gt;
&lt;h2 id="내용"&gt;📌내용
&lt;/h2&gt;&lt;h3 id="격리성은-기본값으로-보장되고-있을까"&gt;격리성은 기본값으로 보장되고 있을까?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;대부분의 RDBMS의 기본 격리 수준은 &lt;code&gt;READ COMMITED&lt;/code&gt; 또는 &lt;code&gt;REPEATABLE READ&lt;/code&gt;이지만 이름은 같아도 구현 방식과 보장 수준은 다르다.&lt;/li&gt;
&lt;li&gt;예를 들어 Oracle의 &lt;code&gt;SERIALIZABLE&lt;/code&gt;은 실제론 &lt;code&gt;SNAPSHOT ISOLATION&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQL의 &lt;code&gt;REPEATABLE READ&lt;/code&gt;는 기본적으로 Phantom Read를 방지하지 않으며&lt;/li&gt;
&lt;li&gt;PostgreSQL은 MVCC 기반이지만 &lt;code&gt;Serializable&lt;/code&gt;을 명시해야만 실제 직렬화 보장을 한다.
&lt;ul&gt;
&lt;li&gt;MVCC: Multi-Version Concurrency Control, 다중 버전 동시성 제어&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;격리 수준은 이름이 같다고 같은 게 아니다.
반드시 DB별 구현 방식을 확인해야 한다.&lt;/p&gt;
&lt;h3 id="격리-수준이-깨질-때-벌어지는-현상들"&gt;격리 수준이 깨질 때 벌어지는 현상들
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;유형&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;예시&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Dirty Read&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;커밋되지 않은 데이터를 읽음&lt;/td&gt;
&lt;td&gt;A가 송금 처리 중인데, B가 중간 상태의 금액을 읽고 합산하여 중복 송금 발생&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Non-Repeatable Read&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;동일 조건으로 두 번 조회했는데 결과가 다름&lt;/td&gt;
&lt;td&gt;A가 상품 재고를 두 번 조회하는 사이, B가 재고를 변경함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Phantom Read&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;같은 쿼리인데 행 개수가 달라짐&lt;/td&gt;
&lt;td&gt;A가 &lt;code&gt;&amp;quot;나이 &amp;gt; 30&amp;quot;&lt;/code&gt; 조건으로 조회 → B가 35세 사용자를 삽입 → A가 다시 조회하면 결과 달라짐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="실무에서-실제-발생한-사례"&gt;실무에서 실제 발생한 사례
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;동시 송금 시스템에서의 경쟁 조건&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 잔액이 100인 상태에서 거의 동시에 두 번 송금 요청을 보냄&lt;/li&gt;
&lt;li&gt;둘 다 잔액 조회 결과 100을 읽고, 각각 80을 송금 → 총 160 송금됨&lt;/li&gt;
&lt;li&gt;이유: &lt;code&gt;READ COMMITTED&lt;/code&gt; 상태에서는 두 트랜잭션이 서로를 고려하지 못함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;해결책은?&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SERIALIZABLE&lt;/code&gt; 수준의 격리 또는 &lt;strong&gt;애플리케이션 차원의 락&lt;/strong&gt; 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ansi-sql-격리-수준-비교표"&gt;ANSI SQL 격리 수준 비교표
&lt;/h3&gt;
&lt;div class="admonition warning"&gt;
&lt;div class="admonition-header"&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"&gt;&lt;path d="M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"/&gt;&lt;/svg&gt;
&lt;span&gt;Warning&lt;/span&gt;
&lt;/div&gt;
&lt;div class="admonition-content"&gt;
&lt;p&gt;격리 수준을 올리면 오류는 줄지만, 성능에 영향을 미친다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;격리 수준 4가지와 이에 따른 현상 3가지가 있다.
이 3가지 현상을 읽기 현상(Read Phenomena)라고 표현한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dirty Read&lt;/strong&gt;: 커밋되지 않은(trash) 데이터를 읽는 현상&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-Repeatable Read&lt;/strong&gt;: 같은 쿼리를 두 번 실행했을 때 결과가 달라지는 현상&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Phantom Read&lt;/strong&gt;: 동일 조건의 쿼리에서 행 개수가 달라지는 현상 (삽입/삭제로 인해)&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;격리 수준&lt;/th&gt;
&lt;th&gt;Dirty Read&lt;/th&gt;
&lt;th&gt;Non-Repeatable Read&lt;/th&gt;
&lt;th&gt;Phantom Read&lt;/th&gt;
&lt;th&gt;비고&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;READ UNCOMMITTED&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;허용&lt;/td&gt;
&lt;td&gt;허용&lt;/td&gt;
&lt;td&gt;허용&lt;/td&gt;
&lt;td&gt;최저 성능, 실사용 거의 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;READ COMMITTED&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;방지&lt;/td&gt;
&lt;td&gt;허용&lt;/td&gt;
&lt;td&gt;허용&lt;/td&gt;
&lt;td&gt;대부분 DB의 기본값&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;REPEATABLE READ&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;방지&lt;/td&gt;
&lt;td&gt;방지&lt;/td&gt;
&lt;td&gt;허용&lt;/td&gt;
&lt;td&gt;MySQL 기본값 (하지만 Phantom Read 방지는 불완전함)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SERIALIZABLE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;방지&lt;/td&gt;
&lt;td&gt;방지&lt;/td&gt;
&lt;td&gt;방지&lt;/td&gt;
&lt;td&gt;가장 강력하나 성능 저하 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="spring에서의-설정-방법"&gt;Spring에서의 설정 방법
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@Transactional&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isolation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Isolation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;SERIALIZABLE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;processTransaction&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Isolation.DEFAULT&lt;/code&gt;: DBMS 기본 설정 따름&lt;/li&gt;
&lt;li&gt;프로젝트에 따라 &lt;code&gt;.yml&lt;/code&gt;, &lt;code&gt;.yaml&lt;/code&gt; 또는 DB 설정에서 전역 기본값을 조정할 수도 있음&lt;/li&gt;
&lt;li&gt;트랜잭션을 사용할 때 &lt;code&gt;@Transactional&lt;/code&gt;만 선언하고 끝이 아니라 어떤 &lt;code&gt;isolation level&lt;/code&gt;이 적용되는지 알아본다면 좋을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="결론"&gt;🎯결론
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;트랜잭션은 선언만으로 안전하지 않다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;격리 수준은 코드의 동작 방식과 데이터 신뢰성을 결정짓는 중요한 요소다.&lt;br&gt;
문제를 겪고 나서야 &amp;ldquo;왜 데이터가 꼬였지?&amp;ldquo;를 고민하기보다, 미리 격리 수준을 설정하고 이해하는 것이 훨씬 값지다.&lt;/p&gt;
&lt;h2 id="endnote"&gt;⚙️EndNote
&lt;/h2&gt;&lt;h3 id="사전-지식"&gt;사전 지식
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션과 커밋/롤백의 개념&lt;/li&gt;
&lt;li&gt;DB 락: Shared Lock vs Exclusive Lock&lt;/li&gt;
&lt;li&gt;MVCC(Multi-Version Concurrency Control)&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://oimbook.tistory.com/entry/Read-Phenomena-in-Transactions" target="_blank" rel="noopener"
&gt;Read Phenomena in Transactions by oim_&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="더-알아보기"&gt;더 알아보기
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://www.postgresql.org/docs/current/transaction-iso.html" target="_blank" rel="noopener"
&gt;PostgreSQL 공식 문서: Isolation Levels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener"
&gt;MySQL InnoDB 트랜잭션 격리 수준&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative.html" target="_blank" rel="noopener"
&gt;Spring Declarative Transaction Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://martin.kleppmann.com/2014/11/25/hermitage-testing-the-i-in-acid.html" target="_blank" rel="noopener"
&gt;Hermitage: Testing the “I” in ACID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://sesoc.tistory.com/317" target="_blank" rel="noopener"
&gt;I-9. 표준 SQL 이란?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29" target="_blank" rel="noopener"
&gt;Isolation (database systems)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>